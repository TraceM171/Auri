package com.auri.extensions.collection

import arrow.core.Either
import arrow.core.getOrElse
import arrow.core.raise.catch
import arrow.core.raise.either
import arrow.core.raise.ensure
import co.touchlab.kermit.Logger
import com.auri.core.collection.Collector
import com.auri.core.collection.CollectorStatus
import com.auri.core.collection.CollectorStatus.*
import com.auri.core.collection.RawCollectedSample
import com.auri.core.common.util.MagicNumber
import com.auri.core.common.util.PeriodicActionConfig
import com.auri.core.common.util.magicNumber
import com.auri.core.common.util.unzip
import com.auri.extensions.collection.common.periodicCollection
import io.ktor.client.*
import io.ktor.client.plugins.*
import io.ktor.client.request.*
import io.ktor.client.request.forms.*
import io.ktor.client.statement.*
import io.ktor.http.*
import io.ktor.util.cio.*
import io.ktor.utils.io.*
import io.ktor.utils.io.streams.*
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.datetime.LocalDate
import kotlinx.datetime.toKotlinLocalDate
import kotlinx.serialization.json.*
import java.net.URI
import java.net.URL
import java.nio.file.Path
import kotlin.io.path.*
import kotlin.time.Duration
import kotlin.time.Duration.Companion.days
import kotlin.time.Duration.Companion.minutes
import kotlin.time.Duration.Companion.seconds
import kotlin.time.TimeMark
import kotlin.time.TimeSource

class MalwareBazaarCollector(
    private val definition: Definition
) : Collector {
    override val name: String = definition.customName
    override val description: String = """
        Collect samples from MalwareBazaar by searching for tags.
        Limitations:
        - Latest 1000 samples per tag
        - 2000 malware sample downloads per day
    """.trimIndent()
    override val version: String = "0.0.1"

    data class Definition(
        val customName: String = "MalwareBazaar",
        val periodicity: PeriodicActionConfig? = PeriodicActionConfig(
            performEvery = 1.days,
            maxRetriesPerPerform = 3,
            skipPerformIfFailed = true,
            retryEvery = 5.minutes
        ),
        val endpointUrl: URL = URI.create("https://mb-api.abuse.ch/api/v1").toURL(),
        val authKey: String,
        val requestCooldown: Duration = 5.seconds,
        val samplesSearchTag: String = "ransomware",
        val samplesLimit: Int = 1000,
        val sampleFileTypeFilter: String = "exe",
        val samplesPassword: String = "infected",
        val samplesMagicNumberFilter: List<MagicNumber> = MagicNumber.entries,
    )


    private val api = Api(
        endpointUrl = definition.endpointUrl,
        authKey = definition.authKey,
        tag = definition.samplesSearchTag,
        limit = definition.samplesLimit,
        requestCooldown = definition.requestCooldown
    )

    @OptIn(ExperimentalCoroutinesApi::class)
    override fun start(
        collectionParameters: Collector.CollectionParameters
    ): Flow<CollectorStatus> = periodicCollection(
        periodicity = definition.periodicity,
        collectionParameters = collectionParameters,
        singleCollection = ::singleSamples
    )

    @OptIn(ExperimentalCoroutinesApi::class)
    private fun singleSamples(
        collectionParameters: Collector.CollectionParameters
    ): Flow<CollectorStatus> = flow {
        emit(Downloading(what = "Latest samples list"))
        val samplesInfo = api.samplesInfo().getOrElse {
            emit(Failed(what = "Query latest samples", why = it))
            return@flow
        }.filter {
            it.fileType == definition.sampleFileTypeFilter
        }
        Logger.i { "Found ${samplesInfo.size} samples with file type ${definition.sampleFileTypeFilter}" }
        emit(Processing(what = "Already downloaded samples"))
        val alreadyDownloadedSamples = collectionParameters.workingDirectory
            .listDirectoryEntries()
            .filter { it.name.endsWith(".zip") }
            .map { it.nameWithoutExtension }
            .toSet()
        Logger.i { "Found ${alreadyDownloadedSamples.size} already downloaded samples" }
        val newSamples = samplesInfo.filter { it.sha256 !in alreadyDownloadedSamples }
        Logger.i { "Found ${newSamples.size} new samples" }
        samplesInfo.forEach { sampleInfo ->
            emit(Processing(what = "Sample ${sampleInfo.sha256}"))
            val destination = collectionParameters.workingDirectory.resolve(sampleInfo.sha256)
            if (sampleInfo in newSamples) {
                emit(Downloading(what = "Sample ${sampleInfo.sha256}"))
                api.downloadSample(sampleInfo, destination).getOrElse {
                    Logger.e { "Failed to download sample ${sampleInfo.sha256}: $it" }
                    return@forEach
                }
                Logger.i { "Successfully downloaded sample ${sampleInfo.sha256}" }
            }
            extractSamples(destination).forEach { sample ->
                val rawSample = RawCollectedSample(
                    submissionDate = sampleInfo.reportedDate,
                    name = sampleInfo.name,
                    executable = sample
                )
                emit(NewSample(rawSample))
            }
        }
    }

    private fun extractSamples(
        zipFile: Path
    ): List<Path> {
        val destinationDir = zipFile.parent.resolve("${zipFile.nameWithoutExtension}_extracted")
        if (!destinationDir.exists()) {
            Logger.d { "Extracting ${zipFile.nameWithoutExtension} with password ${definition.samplesPassword}" }
            zipFile.unzip(destinationDirectory = destinationDir, password = definition.samplesPassword)
            Logger.d { "Successfully extracted ${zipFile.name}" }
        }
        Logger.d { "Searching for extracted executables" }
        val executables = destinationDir.walk()
            .filter { file -> file.magicNumber() in definition.samplesMagicNumberFilter }
            .toList()
        if (executables.isEmpty())
            Logger.i { "No executable found for sample ${zipFile.nameWithoutExtension}" }
        else
            Logger.d { "Found ${executables.size} executables for sample ${zipFile.nameWithoutExtension}" }
        return executables
    }

    private class Api(
        private val endpointUrl: URL,
        private val authKey: String,
        private val tag: String,
        private val limit: Int,
        private val requestCooldown: Duration
    ) : AutoCloseable {
        private var lastRequestMark: TimeMark? = null

        private val client = HttpClient {
            install(HttpTimeout) {
                socketTimeoutMillis = 5.minutes.inWholeMilliseconds
            }
            install(DefaultRequest) {
                url {
                    takeFrom(endpointUrl)
                }
                headers {
                    header("Auth-Key", authKey)
                }
            }
        }

        suspend fun samplesInfo(): Either<String, List<SampleInfo>> = either {
            throttleApi()
            val response = client.submitForm(
                formParameters = parameters {
                    append("query", "get_taginfo")
                    append("tag", tag)
                    append("limit", limit.toString())
                }
            )
            lastRequestMark = TimeSource.Monotonic.markNow()
            ensure(response.status.isSuccess()) {
                "Failed to get samples info: ${response.status}"
            }

            catch(
                {
                    Json.decodeFromString<JsonObject>(response.bodyAsText())["data"]!!.jsonArray.map {
                        val hashesObject = it.jsonObject
                        SampleInfo(
                            sha256 = hashesObject["sha256_hash"]!!.jsonPrimitive.content,
                            reportedDate = java.time.LocalDate.parse(
                                hashesObject["first_seen"]!!.jsonPrimitive.content.substringBeforeLast(
                                    " "
                                )
                            ).toKotlinLocalDate(),
                            name = hashesObject["file_name"]!!.jsonPrimitive.content,
                            fileType = hashesObject["file_type"]!!.jsonPrimitive.content
                        )
                    }
                },
                {
                    raise("Failed to parse samples info: $it")
                }
            )
        }

        suspend fun downloadSample(
            sampleInfo: SampleInfo,
            destination: Path
        ): Either<String, Unit> = either {
            destination.parent.createDirectories()
            throttleApi()
            val response = client.submitForm(
                formParameters = parameters {
                    append("query", "get_file")
                    append("sha256_hash", sampleInfo.sha256)
                }
            )
            lastRequestMark = TimeSource.Monotonic.markNow()
            ensure(response.status.isSuccess()) {
                "Failed to download sample: ${response.status}"
            }
            val body = response.bodyAsChannel()
            destination.outputStream().asByteWriteChannel().use { body.copyTo(this) }
        }

        private suspend fun throttleApi() {
            val timeSinceLastRequest = lastRequestMark?.elapsedNow() ?: Duration.INFINITE
            val remainingDelay = (requestCooldown - timeSinceLastRequest)
            delay(remainingDelay)
        }

        override fun close() {
            client.close()
        }

        data class SampleInfo(
            val sha256: String,
            val reportedDate: LocalDate,
            val name: String,
            val fileType: String
        )
    }
}
